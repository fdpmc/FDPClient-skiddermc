package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.combat

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.features.value.IntegerValue
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import java.util.*
import kotlin.math.abs
import kotlin.random.Random

class VulcanCombatDisabler : DisablerMode("VulcanCombat") {
    private val compDecValue = BoolValue("VulcanDecrease", true)
    private val statDecValue = IntegerValue("VulcanDecreaseDelay", 1500, 500, 2500).displayable { compDecValue.get() }
    private val dynamicValue = BoolValue("VulcanDynamicDelay", true)
    private val decDelayMinValue = IntegerValue("VulcanMinDelay", 4500, 2000, 8000).displayable { dynamicValue.get() }
    private val decDelayMaxValue = IntegerValue("VulcanMaxDelay", 5500, 2000, 8000).displayable { dynamicValue.get() }
    private val minBuffValue = IntegerValue("VulcanMinBuff", 5, 0, 12)
    private var currentTrans = 0
    private var vulTickCounterUID = 0
    
    //已经死了一半的Disabler，稍微复活一下。已经无法（只靠这个Disabler）绕过的Bypass：Vanilla Velocity / None Rotation
    
    private var currentDelay = 5000
    private var currentBuffer = 4
    private var currentDec = -1
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private val lagTimer = MSTimer()
    private val decTimer = MSTimer()
    override fun onEnable() {
        vulTickCounterUID = -25767
        updateLagTime()
        disabler.debugMessage("VulcanCombat Disabler §c§lONLY §r§awork when you rejoined the server!")
    }
    override fun onUpdate(event: UpdateEvent) {
        if (lagTimer.hasTimePassed(currentDelay.toLong()) && packetBuffer.size > currentBuffer) {
            updateLagTime()
            while (packetBuffer.size > currentBuffer) {
                PacketUtils.sendPacketNoEvent(packetBuffer.poll())
            }
        }
        if (decTimer.hasTimePassed(currentDec.toLong()) && currentDec > 0) {
            PacketUtils.sendPacketNoEvent(packetBuffer.poll())
            decTimer.reset()
        }
    }
    override fun onWorld(event: WorldEvent) {
        currentTrans = 0
        packetBuffer.clear()
        updateLagTime()
        vulTickCounterUID = -25767
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (packet is C0FPacketConfirmTransaction) {
            if (abs((abs((packet.uid).toInt()) - abs(vulTickCounterUID))) <= 4) {
                vulTickCounterUID = (packet.uid).toInt()
                packetBuffer.add(packet)
                event.cancelEvent()
                disabler.debugMessage("C0F-PingTickCounter IN ${packetBuffer.size}")
            }else if ((packet.uid).toInt() == -30000){
                packetBuffer.add(packet)
                event.cancelEvent()
                disabler.debugMessage("C0F-OnSpawn IN ${packetBuffer.size}")
            }else if (abs((abs((packet.uid).toInt()) - 25767)) <= 4) {
                vulTickCounterUID = (packet.uid).toInt()
                disabler.debugMessage("C0F-PingTickCounter RESETED")
            }
        }
    }
    fun updateLagTime() {
        decTimer.reset()
        lagTimer.reset()
        if (dynamicValue.get()) {
            currentDelay = Random.nextInt(decDelayMinValue.get(), decDelayMaxValue.get())
        }else {
            currentDelay = 5000
        }
        if (compDecValue.get()) {
            currentDec = statDecValue.get()
        }else {
            currentDec = -1
        }
        currentBuffer = minBuffValue.get()
    }
}
